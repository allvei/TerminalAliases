using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using BepInEx;
using BepInEx.Configuration;
using BepInEx.Logging;
using HarmonyLib;
using LethalConfig;
using LethalConfig.ConfigItems;
using LethalConfig.ConfigItems.Options;
using Microsoft.CodeAnalysis;
using MyFirstMod;
using MyMod;
using Text;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
[assembly: TargetFramework(".NETStandard,Version=v2.1", FrameworkDisplayName = ".NET Standard 2.1")]
[assembly: IgnoresAccessChecksTo("Assembly-CSharp")]
[assembly: AssemblyCompany("allvei.terminalaliases")]
[assembly: AssemblyConfiguration("Debug")]
[assembly: AssemblyFileVersion("0.1.0.0")]
[assembly: AssemblyInformationalVersion("0.1.0+4f47f829e36a020903897c281d21475dc773ed50")]
[assembly: AssemblyProduct("alias plugin")]
[assembly: AssemblyTitle("allvei.terminalaliases")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.1.0.0")]
[module: UnverifiableCode]
[module: RefSafetyRules(11)]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableAttribute : Attribute
	{
		public readonly byte[] NullableFlags;

		public NullableAttribute(byte P_0)
		{
			NullableFlags = new byte[1] { P_0 };
		}

		public NullableAttribute(byte[] P_0)
		{
			NullableFlags = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableContextAttribute : Attribute
	{
		public readonly byte Flag;

		public NullableContextAttribute(byte P_0)
		{
			Flag = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
	internal sealed class RefSafetyRulesAttribute : Attribute
	{
		public readonly int Version;

		public RefSafetyRulesAttribute(int P_0)
		{
			Version = P_0;
		}
	}
}
public class LethalConfigAlias
{
	public void Init()
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Expected O, but got Unknown
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Expected O, but got Unknown
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Expected O, but got Unknown
		LethalConfigManager.SkipAutoGenFor(Text.GlobalConfig.configSection);
		ListKeysValues entriesList = MyMod.GlobalConfig.entriesList;
		ConfigEntry<string> configAddEntryKeys = MyMod.GlobalConfig.config.Bind<string>(LethalConfig.addSection, LethalConfig.keys, "", LethalConfig.addAKey);
		((ConfigEntryBase)configAddEntryKeys).BoxedValue = "";
		configAddEntryKeys.Value = "";
		ConfigEntry<string> configAddEntryValues = MyMod.GlobalConfig.config.Bind<string>(LethalConfig.addSection, LethalConfig.values, "", LethalConfig.addAValue);
		((ConfigEntryBase)configAddEntryValues).BoxedValue = "";
		configAddEntryValues.Value = "";
		LethalConfigManager.AddConfigItem((BaseConfigItem)new GenericButtonConfigItem(LethalConfig.add, LethalConfig.addSection, LethalConfig.addAnAlias, LethalConfig.button, (GenericButtonHandler)delegate
		{
			if (!(configAddEntryKeys.Value == "") && !(configAddEntryValues.Value == ""))
			{
				int num = MyMod.GlobalConfig.entriesList.Append(new KeyValue(configAddEntryKeys.Value, configAddEntryValues.Value));
				ConfigEntry<string> entriesConfig = MyMod.GlobalConfig.entriesConfig;
				entriesConfig.Value = entriesConfig.Value + "; " + configAddEntryKeys.Value + " : " + configAddEntryValues.Value + " ";
				entriesConfig = MyMod.GlobalConfig.entriesConfig;
				((ConfigEntryBase)entriesConfig).BoxedValue = ((ConfigEntryBase)entriesConfig).BoxedValue?.ToString() + "; " + configAddEntryKeys.Value + " : " + configAddEntryValues.Value + " ";
				configAddEntryKeys.Value = "";
				((ConfigEntryBase)configAddEntryKeys).BoxedValue = "";
				configAddEntryValues.Value = "";
				((ConfigEntryBase)configAddEntryValues).BoxedValue = "";
				MyMod.GlobalConfig.config.Save();
			}
		}));
		ConfigEntry<string> searchConfigEntryKey = MyMod.GlobalConfig.config.Bind<string>(LethalConfig.search, LethalConfig.key, "", LethalConfig.searchKey);
		ConfigEntry<string> searchConfigEntryValue = MyMod.GlobalConfig.config.Bind<string>(LethalConfig.search, LethalConfig.value, "", LethalConfig.resultValue);
		LethalConfigManager.AddConfigItem((BaseConfigItem)new GenericButtonConfigItem(LethalConfig.search, LethalConfig.search, LethalConfig.searchDesc, LethalConfig.button, (GenericButtonHandler)delegate
		{
			((ConfigEntryBase)searchConfigEntryValue).BoxedValue = MyMod.GlobalConfig.entriesList.SearchByKey(searchConfigEntryKey.Value);
		}));
	}
}
[HarmonyPatch(typeof(Terminal))]
internal class AliasPatch
{
	[HarmonyPatch(typeof(Terminal), "ParsePlayerSentence")]
	[HarmonyPrefix]
	private static void TestAlias(ref Terminal __instance)
	{
		bool modifyingText = __instance.modifyingText;
		__instance.modifyingText = true;
		string text = __instance.screenText.text.Substring(__instance.screenText.text.Length - __instance.textAdded);
		int length = text.Length;
		if (length <= 0)
		{
			return;
		}
		for (int i = 0; i < ListKeysValues.keyValues.Count; i++)
		{
			if (text.Length <= ListKeysValues.keyValues[i].key.Length)
			{
				text = text.Replace(ListKeysValues.keyValues[i].key, ListKeysValues.keyValues[i].value);
			}
		}
		__instance.screenText.text = __instance.screenText.text.Substring(0, __instance.screenText.text.Length - __instance.textAdded) + text;
		__instance.textAdded += text.Length - length;
		__instance.modifyingText = modifyingText;
	}
}
namespace Text
{
	internal class GlobalConfig
	{
		public static string default_value = " vm : VIEW MONITOR ; sw : SWITCH ; s : SWITCH ; p : PING ; t : TRANSMIT ; sc : SCAN ; st : STORE ; m : MOONS ; tcb : THE COMPANY BUILDING ; exp : EXPERIMENTATION ; ass : ASSURANCE ; v : VOW ; ma : MARCH ; off : OFFENSE ; ad : ADAMANCE ; re : REND ; di : DINE ; ti : TITAN";

		public static string warningMessageBadElement = "[alias plugin] : An element cannot be initialized. Continue to the next one. Element:";

		public static string configSection = "All alias";

		public static string KeyConfig = "List alias";

		public static string description = "To put your alias -> \"my alias : command \"";
	}
	internal class init
	{
		public static string finishLoaded = "allvei.terminalaliases v0.1.0 has loaded!";

		public static string finishPatch = "Finished patching!";
	}
	internal class LethalConfig
	{
		public static string display = "Display";

		public static string keys = "Keys";

		public static string key = "Key";

		public static string values = "Values";

		public static string value = "value";

		public static string resultValue = "Result value";

		public static string descAllKeys = "All keys with structure -> key : value";

		public static string addSection = "Add";

		public static string add = "Add";

		public static string addAnAlias = "Add an alias. Be careful, key and value must not be empty";

		public static string addAKey = "Add a key";

		public static string addAValue = "Add a value";

		public static string remove = "Remove";

		public static string removeAnAlias = "Remove an alias";

		public static string search = "Search";

		public static string searchKey = "Search a value from a key";

		public static string searchDesc = "Click to search. Key must not be empty";

		public static string button = "click";

		public static string unbind = "Unbind";

		public static string sucess = "Sucess";

		public static string alias = "Alias-";
	}
}
namespace MyMod
{
	public struct KeyValue
	{
		public string key;

		public string value;

		public KeyValue(string key, string value)
		{
			this.key = key;
			this.value = value;
		}
	}
	public struct ListKeysValues
	{
		public static List<KeyValue> keyValues = new List<KeyValue>();

		public static List<ConfigEntry<string>> listConfigAliasKey = new List<ConfigEntry<string>>();

		public static List<ConfigEntry<string>> listConfigAliasValue = new List<ConfigEntry<string>>();

		public string keysStr;

		public string valuesStr;

		public string keysValuesStr;

		public ListKeysValues(string keysStr, string valuesStr, string keysValuesStr)
		{
			this.keysStr = keysStr;
			this.valuesStr = valuesStr;
			this.keysValuesStr = keysValuesStr;
		}

		public int Append(KeyValue keyValue, bool addToConfig = false)
		{
			//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ff: Expected O, but got Unknown
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0204: Expected O, but got Unknown
			string text = keyValue.key.TrimEnd();
			text = keyValue.key.TrimStart();
			if (SearchByKey(text) != "None")
			{
				return -1;
			}
			keyValue.key = text;
			keyValues.Add(keyValue);
			keysStr = keysStr + "; " + keyValue.key + " ";
			valuesStr = valuesStr + "; " + keyValue.value + " ";
			keysValuesStr = keysValuesStr + "; " + keyValue.key + " : " + keyValue.value + " ";
			int index = keyValues.Count() - 1;
			listConfigAliasKey.Add(GlobalConfig.config.Bind<string>(LethalConfig.alias + index, LethalConfig.key, "", ""));
			listConfigAliasKey[index].Value = keyValue.key;
			((ConfigEntryBase)listConfigAliasKey[index]).BoxedValue = keyValue.key;
			listConfigAliasValue.Add(GlobalConfig.config.Bind<string>(LethalConfig.alias + index, LethalConfig.value, "", ""));
			listConfigAliasValue[index].Value = keyValue.value;
			((ConfigEntryBase)listConfigAliasValue[index]).BoxedValue = keyValue.value;
			LethalConfigManager.AddConfigItem((BaseConfigItem)new GenericButtonConfigItem(LethalConfig.alias + index, LethalConfig.remove, LethalConfig.removeAnAlias, LethalConfig.button, (GenericButtonHandler)delegate
			{
				if (index < listConfigAliasKey.Count())
				{
					GlobalConfig.entriesList.RemoveByKey(listConfigAliasKey[index].Value);
				}
			}));
			return index;
		}

		public string SearchByKey(string key)
		{
			key = key.TrimEnd();
			key = key.TrimStart();
			foreach (KeyValue keyValue in keyValues)
			{
				if (keyValue.key == key)
				{
					return keyValue.value;
				}
			}
			return "None";
		}

		public bool RemoveByKey(string key)
		{
			key = key.TrimEnd();
			key = key.TrimStart();
			int i;
			for (i = 0; i < keyValues.Count && !(keyValues[i].key == key); i++)
			{
			}
			if (i >= keyValues.Count)
			{
				return false;
			}
			keysStr = keysStr.Replace(keyValues[i].key, "");
			valuesStr = valuesStr.Replace(keyValues[i].value, "");
			keysValuesStr = keysValuesStr.Replace(keyValues[i].key + " : " + keyValues[i].value, "");
			GlobalConfig.entriesConfig.Value = keysValuesStr;
			((ConfigEntryBase)GlobalConfig.entriesConfig).BoxedValue = keysValuesStr;
			keyValues.RemoveAt(i);
			for (int j = 0; j < keyValues.Count; j++)
			{
				listConfigAliasKey[j].Value = keyValues[j].key;
				((ConfigEntryBase)listConfigAliasKey[j]).BoxedValue = keyValues[j].key;
				listConfigAliasValue[j].Value = keyValues[j].value;
				((ConfigEntryBase)listConfigAliasValue[j]).BoxedValue = keyValues[j].value;
			}
			ConfigEntry<string> val = GlobalConfig.config.Bind<string>(LethalConfig.alias + keyValues.Count(), LethalConfig.key, "", "");
			val.Value = "";
			((ConfigEntryBase)val).BoxedValue = "";
			ConfigEntry<string> val2 = GlobalConfig.config.Bind<string>(LethalConfig.alias + keyValues.Count(), LethalConfig.value, "", "");
			val2.Value = "";
			((ConfigEntryBase)val2).BoxedValue = "";
			GlobalConfig.config.Save();
			return true;
		}
	}
	public class GlobalConfig
	{
		[Serializable]
		[CompilerGenerated]
		private sealed class <>c
		{
			public static readonly <>c <>9 = new <>c();

			public static GenericButtonHandler <>9__4_0;

			internal void <SetCOnfig>b__4_0()
			{
			}
		}

		public static ConfigEntry<string> entriesConfig;

		public static ListKeysValues entriesList = new ListKeysValues("", "", "");

		public static ConfigFile config;

		public GlobalConfig(ConfigFile cfg)
		{
			config = cfg;
			cfg.SaveOnConfigSet = false;
			entriesConfig = cfg.Bind<string>(Text.GlobalConfig.configSection, Text.GlobalConfig.KeyConfig, Text.GlobalConfig.default_value, Text.GlobalConfig.description);
			cfg.Save();
			cfg.SaveOnConfigSet = true;
		}

		public void SetCOnfig()
		{
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e9: Expected O, but got Unknown
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Expected O, but got Unknown
			List<string> list = entriesConfig.Value.Split(';', StringSplitOptions.RemoveEmptyEntries).ToList();
			for (int i = 0; i < list.Count; i++)
			{
				List<string> list2 = list[i].Split(':', StringSplitOptions.RemoveEmptyEntries).ToList();
				if (list2.Count != 2)
				{
					AliasPlugin.Logger.LogWarning((object)(Text.GlobalConfig.warningMessageBadElement + list2.ToString()));
					continue;
				}
				string text = list2[0];
				text = text.TrimStart();
				text = text.TrimEnd();
				string text2 = list2[1];
				text2 = text2.TrimStart();
				text2 = text2.TrimEnd();
				entriesList.Append(new KeyValue(text, text2));
				AliasPlugin.Logger.LogDebug((object)("Content config" + ListKeysValues.keyValues.Count));
			}
			for (int j = 0; j < 8; j++)
			{
				ConfigEntry<string> val = config.Bind<string>(LethalConfig.alias + (list.Count + j), LethalConfig.key, "", "");
				val.Value = "";
				((ConfigEntryBase)val).BoxedValue = "";
				ConfigEntry<string> val2 = config.Bind<string>(LethalConfig.alias + (list.Count + j), LethalConfig.value, "", "");
				val2.Value = "";
				((ConfigEntryBase)val2).BoxedValue = "";
				string text3 = LethalConfig.alias + (list.Count + j);
				string remove = LethalConfig.remove;
				string removeAnAlias = LethalConfig.removeAnAlias;
				string button = LethalConfig.button;
				object obj = <>c.<>9__4_0;
				if (obj == null)
				{
					GenericButtonHandler val3 = delegate
					{
					};
					<>c.<>9__4_0 = val3;
					obj = (object)val3;
				}
				LethalConfigManager.AddConfigItem((BaseConfigItem)new GenericButtonConfigItem(text3, remove, removeAnAlias, button, (GenericButtonHandler)obj));
			}
			AliasPlugin.Logger.LogDebug((object)("Content Init end " + ListKeysValues.keyValues.Count));
		}
	}
}
namespace MyFirstMod
{
	[BepInPlugin("allvei.terminalaliases", "alias plugin", "0.1.0")]
	[BepInDependency(/*Could not decode attribute arguments.*/)]
	public class AliasPlugin : BaseUnityPlugin
	{
		internal static MyMod.GlobalConfig BoundConfig { get; private set; }

		public static AliasPlugin Instance { get; private set; }

		internal static Harmony? Harmony { get; set; }

		internal static ManualLogSource Logger { get; private set; }

		private void Awake()
		{
			Logger = ((BaseUnityPlugin)this).Logger;
			Instance = this;
			BoundConfig = new MyMod.GlobalConfig(((BaseUnityPlugin)this).Config);
			BoundConfig.SetCOnfig();
			Patch();
			Logger.LogInfo((object)init.finishLoaded);
			LethalConfigAlias lethalConfigAlias = new LethalConfigAlias();
			lethalConfigAlias.Init();
		}

		internal static void Patch()
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Expected O, but got Unknown
			if (Harmony == null)
			{
				Harmony = new Harmony("allvei.terminalaliases");
			}
			Harmony.PatchAll(typeof(AliasPatch));
			Logger.LogDebug((object)init.finishPatch);
		}

		internal static void Unpatch()
		{
			Harmony? harmony = Harmony;
			if (harmony != null)
			{
				harmony.UnpatchSelf();
			}
		}
	}
	public static class MyPluginInfo
	{
		public const string PLUGIN_GUID = "com.github.allvei.lethalaliases";

		public const string PLUGIN_NAME = "alias plugin";

		public const string PLUGIN_VERSION = "0.1.0";

		public const string PLUGIN_WEBSITE = "https://github.com/allvei/TerminalAliases";

		public const string PLUGIN_AUTHOR = "xCape";
	}
}
namespace System.Runtime.CompilerServices
{
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
	internal sealed class IgnoresAccessChecksToAttribute : Attribute
	{
		public IgnoresAccessChecksToAttribute(string assemblyName)
		{
		}
	}
}
